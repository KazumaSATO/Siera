---
layout: post
title: "3주차 init"
date:	2020-06-30 20:16:56
categories: update
tags: init 동아리
image: /images/pic01.jpg
---
# init

_ _ _

<br>
        
## 백준 알고리즘 2750번           
<img src="https://github.com/objectio/objectio.github.io/blob/master/images/init.JPG?raw=true" width="90%">             
         
오름차순으로 정렬하기 위하여      
정렬되지 않은 숫자들 중 가장 작은 수를 선택하여        
정렬된 왼쪽에 크기가 작은 순으로 이동하는 **선택정렬**을 이용하였다.        
코드는 다음과 같다.         
             
```
#include <iostream>
using namespace std;
void selection_sort(int array[], int n);

int main() {
	int array[1000];
	int N;
	cin >> N;
	for (int i = 0; i < N; i++)
		cin >> array[i];

	selection_sort(array, N);

	for (int i = 0; i < N; i++)
		cout << array[i] << endl;

	return 0;
}

void selection_sort(int array[], int n)
{
	for (int i = 0; i < n - 1; i++) {
		int least = i;
		for (int j = i + 1; j < n; j++) {
			if (array[least] > array[j])
				least = j;
		}
		int temp = array[i];
		array[i] = array[least];
		array[least] = temp;
	}
}
```
       
### 결과는?             
<img src="https://github.com/objectio/objectio.github.io/blob/master/images/init-1.JPG?raw=true" width="90%">             
           
#### 정답이다!^^             
<br>

_ _ _

## 백준 알고리즘 2751번
<img src="https://github.com/objectio/objectio.github.io/blob/master/images/init/init-1-2.1.JPG?raw=true" width = "90%">               
            
쪼개서 문제를 해결하는 분할정복 알고리즘 중 퀵 정렬을 사용하여 문제 해결을 시도하였다.        
코드는 다음과 같다.        
```
#include <iostream>
using namespace std;
void quick_sort(int data[], int start, int end);

int main() {

	int array[1000];
	int N;
	cin >> N;
	for (int i = 0; i < N; i++)
		cin >> array[i];

	quick_sort(array, 0, N - 1);

	for (int i = 0; i < N; i++)
		cout << array[i] << endl;

	return 0;
}

void quick_sort(int data[], int start, int end) {
	if (start >= end) return;

	int pivot = start;
	int i = pivot + 1;
	int j = end;
	int temp;

	while (i <= j) {
		while (i <= end && data[i] <= data[pivot]) i++;
		while (j > start && data[j] >= data[pivot]) j--;
		if (i > j) {
			temp = data[j];
			data[j] = data[pivot];
			data[pivot] = temp;
		}
		else {
			temp = data[i];
			data[i] = data[j];
			data[j] = temp;
		}
	}
	quick_sort(data, start, j - 1);
	quick_sort(data, j + 1, end);
}
```
동아리 시간에 배웠던 코드를 참고해서 짰다. 사실 완벽히 숙지하지 않아서 피피티와 거의 똑같지만 손으로 한번씩 변수 역할 생각해보면서 받아적어보니 알고리즘은 이해한 것 같다. 복습을 했었는데 분명... 왜 다 까먹었지.. 퀵소트는 항상 변수가 많아서 까먹는다...^^            
          
### 결과는?
<img src="https://github.com/objectio/objectio.github.io/blob/master/images/init/init-1-2.2.JPG?raw=true" width="90%">        

#### 조금.. 당황했다. 

분명 코드를 맞게 짠 거 같은데...         
사실 짜면서 조금 불안했던 게 퀵 정렬은 재귀 호출을 사용하기 때문에 비효율적이다. 한 번 재귀호출될 때마다 메모리에 쌓여서 용량면에서 비효율적이라고 한다.       
시간면에서 보자면 퀵 정렬은 최악의 경우에 시간복잡도가 매우,, 높아져 시간이 오래걸린다.         
퀵소트의 최악의 경우 시간복잡도를 찾아보니 O(N^2)라고 한다.       
백준 알고리즘에서 채점할 때 시간은 엄격하게 보는 건 알고 있었지만 용량도 빡세게 제한하는지는 모르겠다!           
           
엥? 다시 보니 시간 초과가 아니라 런타임 에러라고 떠있다. 풀어서 맞았던 2750번과 배열 똑같이 했는데???????        
안되겠다. 나중에 합병 정렬로 다시 풀어봐야겠다. 합병 정렬로 했는데도 안되면 새벽동안 머리채를 쥐뜯어야지.        
<br>

_ _ _

## 백준 알고리즘 10814번             

처음에는 배열로 풀려고 했었는데 중간에 막혀서 허둥지둥 대다가 친구의 도움으로 벡터를 써보기로 했다! 다행히 소웨경을 나가면서 벡터를 이용한 경험이 많아 금방 코드를 짤 수 있었다. 
### 결과는?